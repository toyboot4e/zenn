---
title: "Haskell の浅瀬"
---


# モチベーション

僕は Haskell を背伸びして使っています。仙界の麓のコードモンキーです。いくら修行したって徳を積めた気はしませんが、とにかく Haskell が楽しい。しかも Haskell の浅瀬で延々と遊び続けています。

何が面白いかと言えば、一言で言えば『純粋関数型プログラミング』です。 Haskell には、手続き型言語における `for` 文、 `return` 文のような制御構文と、可変変数がありません。代わりにクロージャを使い、しかも死ぬほどネストします。


# 純粋関数型の手続き的プログラミング


## 1. 関数の出力を関数の入力に繋ぐ

もしも凄そうな響きがあったら、説明が悪いだけなのでご勘弁ください。ともかく最近の僕は Haskell で書く普通の手続き的プログラミングに夢中になっています。

たとえばループ処理です。セグメント木の区間取得が以下になります:

```haskell
-- [l, r] 区間のモノイド積を取得する
inner l r !smL !smR
  | l > r = pure $! smL <> smR
  | otherwise = do
      -- この段のモノイドを取得して結合する
      !smL' <-
        if testBit l 0
          then (smL <>) <$> VGM.read dSt l
          else pure smL
      !smR' <-
        if not $ testBit r 0
          then (<> smR) <$> VGM.read dSt r
          else pure smR
      -- 1 段上に上がる
      inner ((l + 1) .>>. 1) ((r - 1) .>>. 1) smL' smR'
```

こうしたループ処理の面白い点は、状態を引数として持っている点です。末尾の `inner` 関数呼び出しで、この `inner` 関数の出力が次の `inner` 関数呼び出しの入力になります。このように、前の関数から次の関数へ値を渡す処理が繰り返されて、プログラム全体が構成されるのが面白いです。


## 2. あくまで可変変数は無い

Haskell で可変変数を扱うためには、 `IO` か `ST` モナドを使います。これらは可変変数の入ったヒープ領域全体を載せた `State` モナドのような表現になります。したがって可変変数へのアクセスは `IO` / `ST` から値を取り出す形になります。

このような `IO` モナドでは、何でもできる『チートモード』にはなりません。たとえば可変長配列 ([GrowVec.hs](https://github.com/toyboot4e/ac-library-hs/blob/2a5083aeca24896b9fe595edc0eb7f9e4cc6d8fd/src/AtCoder/Internal/GrowVec.hs)) を作った際は、可変配列へのポインタ (`MVector`) 自体を書き換え可能にするため、 `MVector` を [`MutVar`](https://hackage.haskell.org/package/primitive-0.9.0.0/docs/Data-Primitive-MutVar.html) に包む必要がありました。使いにくい上にパフォーマンスも落ちます。でもそれを含めて面白いです。


# まとめ

Haskell における手続き的プログラミングへの興味関心を振り返りました。以前は『手続き的なコードを書くようになったから Haskell を使っている意味が無い』と考えていましたが、今は手続き的なコードにも十分に純粋関数型の特性が現れているように思います (※ ポジショントークです) 。このように普通の Haskell を書きながら、値の受け渡しを感覚するのに夢中になっています。

Haskell が良い、役に立つというような観点は特に持っていないのですが、『純粋関数型プログラミングにおいてはこのように表現せざるを得ない』という事情が見えるのが楽しいです。
