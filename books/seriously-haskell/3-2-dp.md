---
title: "[3-2] 動的計画法を得意技にする"
---

動的計画法は茶〜レーティングを目指す上で必須の問題です。

動的計画法 (DP) の問題は、大体が配列とループで解けます。 Haskell においてはループを 2 つに分類し、畳み込みまたは `constructN` で解けると言って良いでしょう。ただし配る DP をする際には特別な関数を自分で作る必要があると思います。

:::message
この章は時間の都合で簡単な説明となります。初めて動的計画法の問題を解く場合は、以下の説明はおすすめできません。
:::

# 語彙

動的計画法においては配列にモノイドを載せます。配列中の要素への作用はモノイドの結合として表される場合が多く、『緩和』として知られています。たとえばナップサック問題においては `Max` モノイドを考え、 `minBound` を単位元とし、 `max` 演算子で緩和します。

# 主な DP のパターン

## 1. 畳み込みで解ける DP

ナップサック問題のような DP は畳み込みで解くことができます。入力を 1 つ受け取ることに、手持ちの状態を 1 つ進めることを繰り返します。

ここでモノイドを意識して緩和の演算を考えると整理がつく上に、実装も簡単になります。

- 配列中の無効なスロットはモノイドの単位元にします。たとえばナップサック問題においては `max` で緩和しますが、空きスロットを `minBound` にします (`-1` などにしない方が良いです) 。

なお可変配列を使った in-place な配列更新はおすすめしません。時系列が影響する点がデメリットな一方で、パフォーマンス面でも大きなメリットは無いと思います (~ 1.5 倍速程度？) 。

## 2. `constructN` で解ける DP

[`constructN`] を手続き型プログラミングに対応させると、 n 回ループして n 回配列に `pushBack` する関数です。

DP 配列の添字がトポロジカル順になるよう設計すれば、 `constructN` によって受け取る DP ができます。たとえば集合 DP においては $0, 1, .. 2^n - 1$ は bit 集合としてトポロジカルソートされています。区間 DP においても `arr ! (l, r)` ではなく `arr ! (len, l)` のように添字を取れば `constructN` で解くことができます。 2 次元累積和なども `constructN` で計算できますし、 `vector` をラッパーで包めば `Ix` クラス越しのアクセサを提供することもできます。

なお遅延評価とメモ化再帰は、極端に遅くなる場合があるためおすすめしません。

## 3. `constructN` 風の配る DP

DP 配列の添字がトポロジカル順であって配る DP をやりたいときは、そういった関数を自分で作るしかないと思います。

[`constructN`]: https://www.stackage.org/haddock/lts-21.7/vector-0.13.0.0/Data-Vector-Unboxed.html#v:constructN

# まとめ

動的計画法における実装のコツをお伝えしました。 Haskell においては簡単な実装を指向するほど問題の性質を抜き出すことが要求されて、気付きも増えるように感じます。半環やトロピカル演算を唱えだす人もおり、これは Haskeller の環境的な強みかもしれません。

