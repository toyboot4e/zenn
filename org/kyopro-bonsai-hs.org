#+TITLE: 競プロ盆栽.hs
#+BOOK_DIR: ../books/kyopro-bonsai-hs
#+PROPERTY: header-args :results output
#+LINK: =ac-library-hs= https://github.com/toyboot4e/ac-library-hs

* スクリプト

#+NAME: zenn-headings
#+BEGIN_SRC elisp :results output
(org-map-entries
  (lambda ()
    (let* ((title (org-entry-get nil "EXPORT_FILE_NAME"))
           (is-draft (org-entry-get nil "DRAFT")))
      (when (and title (not is-draft))
        (princ (concat "- " title "\n")))))
  "LEVEL=1")
#+END_SRC

* =config.yaml=
:PROPERTIES:
:DRAFT:
:END:

#+BEGIN_SRC yaml :tangle ../books/kyopro-bonsai-hs/config.yaml :noweb yes
title: "競プロ盆栽.hs"
summary: "Haskell の AtCoder 用自作ライブラリ解説"
topics: ["haskell", "atcoder"]
published: false
price: 0
chapters:
<<zenn-headings()>>
#+END_SRC

* 表紙
:PROPERTIES:
:EXPORT_FILE_NAME: cover
:END:

#+BEGIN_EXPORT markdown
![cover](/images/kyopro-bonsai-hs/cover.png)
*表紙イラスト [杉本早](https://www.sugimotosaki.com/) 様依頼品*
*λ を育てよ！*
#+END_EXPORT

* 始めに
:PROPERTIES:
:EXPORT_FILE_NAME: intro
:END:

[[https://qiita.com/advent-calendar/2024/haskell][Haskell Advent Calendar 2024]] 22 日目の投稿です。

** 概要

これは [[https://github.com/atcoder/ac-library][AtCoder Library (ACL)]] を Haskell に移植した際の *ブログ* です。 [[https://github.com/toyboot4e/ac-library-hs][ac-library-hs]] の開発をダシに、競プロ文脈で Haskell を学ぶとこうなる、という具体例を延々とやって行きます。

『競プロ盆栽』というタイトルですが、 *Haskeller 向けの投稿* です。競プロ er で読みに来てくれた人がいたら、すみません！　お求めの物ではないかもしれません。お詫びに λ をお送りします。 / λ λ λ λ λ λ λ / ﾗﾑﾀﾞｲｯﾁｮｰ

難度感としては、『Haskellで戦う競技プログラミング 第2版』を熟読した (or する) ぐらいの人が読めると思います。 [[https://hackage.haskell.org/package/primitive-0.9.0.0/docs/Control-Monad-Primitive.html#t:PrimMonad][=PrimMonad=]] が使える／興味があるぐらいの人にちょうど良いかと思います。

#+BEGIN_EXPORT markdown
https://booth.pm/ja/items/1577541
#+END_EXPORT

また投稿の内容はブログであり、技術情報の還元ではなく、僕が調べた・考えたことのごった煮になります。「そうそうそう」と頷ける部分があれば、「これは違う！」と嘆かれることもありそうですが、いかんせんコンテンツの少ない界隈ですので、お楽しみ頂ける部分があれば幸いです。

** 動作環境

以下の環境で作業しました。

- Linux
- GHC 9.8.3

* Haskell の浅瀬
:PROPERTIES:
:EXPORT_FILE_NAME: beginner
:END:

** モチベーション

僕は Haskell を背伸びして使っています。仙界の麓のコードモンキーです。いくら修行したって徳を積めた気はしませんが、とにかく Haskell が楽しい。しかも Haskell の浅瀬で延々と遊び続けています。

何が面白いかと言えば、一言で言えば『純粋関数型プログラミング』です。 Haskell には、手続き型言語における =for= 文、 =return= 文のような制御構文と、可変変数がありません。代わりにクロージャを使い、しかも死ぬほどネストします。

** 純粋関数型の面白いところ

*** 1. 関数の出力を関数の入力に繋ぐ

もしも凄そうな響きがあったら、説明が悪かっただけなので忘れてください。とにかく最近僕が楽しいのは、次のような普通のコードを書くことです。

たとえばループ処理です。無駄にゴツいコードで申し訳ないのですが、セグメント木の区間取得のコードになります。

#+BEGIN_SRC haskell
-- [l, r] 区間のモノイドの積を取得する
inner l r !smL !smR
  | l > r = pure $! smL <> smR
  | otherwise = do
      -- この段のモノイドを取得して結合する
      !smL' <-
        if testBit l 0
          then (smL <>) <$> VGM.read dSt l
          else pure smL
      !smR' <-
        if not $ testBit r 0
          then (<> smR) <$> VGM.read dSt r
          else pure smR
      -- 1 段上に上がる
      inner ((l + 1) .>>. 1) ((r - 1) .>>. 1) smL' smR'
#+END_SRC

こうしたループ処理の面白い点は、状態を引数として持っている点です。末尾の =inner= 関数呼び出しで、 =inner= 関数の出力が次の =inner= 関数呼び出しの入力になります。このように、前の関数から次の関数へ値を渡す処理が繰り替えされて、プログラム全体が構成されるのが面白いです。

*** 2. あくまで可変変数は無い

Haskell の可変変数はヒープ領域にあります。スタック領域に置けるのは、ヒープ領域へのポインタです。ヒープ領域からデータを取り出す際には、 =ST= または =IO= モナドを介します。

=IO= や =ST= モナドは、可変変数の入ったヒープ領域全体を載せた =State= モナドのような表現です。ヒープの中身は変化しますが、スタック上の変数はすべて immutable ですし、ヒープの中からデータを取り出すためには =IO= / =ST= モナドを介する必要があります。

したがって =IO= モナドは何でもできる『チートモード』にはなりません。たとえば可変長配列 ([[https://github.com/toyboot4e/ac-library-hs/blob/2a5083aeca24896b9fe595edc0eb7f9e4cc6d8fd/src/AtCoder/Internal/GrowVec.hs][GrowVec.hs]]) を作った際には、可変配列へのポインタ (=MVector=) 自体を書き換え可能にするために、 [[https://hackage.haskell.org/package/primitive-0.9.0.0/docs/Data-Primitive-MutVar.html][=MutVar=]] に包みました。使いにくい上にパフォーマンスも落ちます。でも面白い！

** まとめ

純粋関数型言語における普通の手続き型プログラミングを振り返りました。以前は『手続き的なコードを書くようになったから Haskell を使っている意味が無い』と考えていましたが、今は手続き的なコードにも十分に純粋関数型の特性が現れているように思います (※ ポジショントークです) 。

Haskell が良い、役に立つというような観点は特に持っていないのですが、『純粋関数型プログラミングならばこう表現せざるを得ない』というような事情が見えるのがとても楽しいです。

* State ベースのパーサ
:PROPERTIES:
:EXPORT_FILE_NAME: parser
:END:

** 標準入力をパースする

競技プログラミングでは、通常、標準入力として入力データが与えられます。 [[=ac-library-hs=][=ac-library-hs=]] においては、簡単なパーサ ([[https://github.com/toyboot4e/ac-library-hs/blob/2a5083aeca24896b9fe595edc0eb7f9e4cc6d8fd/verify/src/Util.hs][=Util.hs=]]) を用意して [[https://atcoder.jp/contests/practice2][AtCoder Library Practice Contest]] の問題を解きました。モチベーションと共に、パーサの内容を解説します。

** 入力の先読み

[[https://atcoder.jp/contests/practice2/tasks/practice2_k][Range Affine Range Sum]] の入力では、クエリ種別によって行のフォーマットが変わります。

- クエリ種別 0: =0 l r b c=
- クエリ種別 1: =1 l r=

いずれも 5 値のタプル、つまり [[https://hackage.haskell.org/package/vector-0.13.2.0/docs/Data-Vector-Unboxed.html#t:Unbox][=Unbox=]] なデータ型にパースして =vector= に保存したいとします。そのため各行一単語目のクエリ種別 (=0= または =1=) を見て分岐する必要があります。しかし Haskell においては、行単位 ([[https://hackage.haskell.org/package/bytestring-0.12.2.0/docs/Data-ByteString.html#v:getLine][=getLine=]]) でしか標準入力を取得できません。対策を考えます。

*** リストを経由する方法

定型的なテンプレートで処理する方法としは、一度リストにパースしてから、タプルに変換することができます。やや釈然としませんが、無難に動作します。

テンプレート部分は以下です:

#+BEGIN_SRC haskell
import Data.ByteString.Char8 qualified as BS
import Data.Functor ((<&>))
import Data.List qualified as L
import Data.Vector.Unboxed qualified as VU
import GHC.Stack (HasCallStack)

intList :: (HasCallStack) => IO [Int]
intList = L.unfoldr (BS.readInt . BS.dropSpace) <$> BS.getLine
#+END_SRC

パース部分では、次のように処理します:

#+BEGIN_SRC haskell
main :: IO ()
main = do
  (!_, !q) <- intList
  xs <- intList
  -- クエリを読み込む部分:
  qs <- VU.replicateM q $ do
    intList <&> \case
      [0, !l, !r, !b, !c] -> (0 :: Int, l, r, b, c)
      [1, !l, !r]  -> (1 :: Int, l, r, -1, -1)
      _ -> error "unreachable"
#+END_SRC

*** バッファに入れて処理する方法

C++ の解答では =scanf= や =cin= を使い、単語単位で標準入力を読んでいるものが多いです:

#+BEGIN_SRC cpp
int t;
scanf("%d", &t);
if (t == 0) {
    int l, r, c, d;
    scanf("%d %d %d %d", &l, &r, &c, &d);
    seg.apply(l, r, F{c, d});
} else {
    int l, r;
    scanf("%d %d", &l, &r);
    printf("%d\n", seg.prod(l, r).a.val());
}
#+END_SRC

Haskell においても =scanf= / =cin= が欲しいと思うと、 [[https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-State-Strict.html][=Stete=]] モナドを使うのが近いです。標準入力をバッファ (=Stete= モナド) に入れて、単語単位で読み取っていきます。

パーサ型を以下とします:

#+BEGIN_SRC haskell
import Control.Monad.Trans.State.Strict (StateT (..), evalStateT)

type Parser = StateT BS.ByteString Maybe

-- | バッファから一単語読んで `Int` 型にパースする
intP :: Parser Int
intP = StateT $ BS.readInt . BS.dropSpace
#+END_SRC

一行読んでバッファに入れて、パーサで処理する関数が以下です。部分関数になりますが、 =fromJust= で値を取り出してしまいます:

#+BEGIN_SRC haskell
withLine :: (HasCallStack) => Parser a -> IO a
withLine f = fromJust . evalStateT f <$> BS.getLine
#+END_SRC

クエリ部分では、次のようにパースできます:

#+BEGIN_SRC haskell
  qs <- VU.replicateM q $ do
    withLine $
      intP >>= \case
        0 -> (0 :: Int,,,,) <$> intP <*> intP <*> intP <*> intP
        1 -> (1,,,-1,-1) <$> intP <*> intP
        _ -> error "unreachable"
#+END_SRC

なお標準入力全体を [[https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-State-Strict.html][=Stete=]] モナドに入れておけば、 =withLine= は省略可能です。

** パーサの合成

[[https://atcoder.jp/contests/abc385/tasks/abc385_d][ABC 385 - D]] では、やや複雑な入力が与えられました。特に $D_i, C_i$ の部分を抜き出すと、一単語目が方向 (=Char=) 、二単語目が移動量 (=Int=) となります:

#+BEGIN_SRC text
L 2
D 1
R 1
U 2
#+END_SRC

ここで =Char= のパーサを追加します:

#+BEGIN_SRC haskell
charP :: Parser Char
charP = StateT $ BS.uncons . BS.dropSpace
#+END_SRC

すると次のように、 =charP=, =intP= を組み合わせて =(Char, Int)= のパーサを作って使用できます:

#+BEGIN_SRC haskell
!movements <- U.replicateM m (withLine ((,) <$> charP <*> intP))
#+END_SRC

これは格好いい！　しかも即席のパーサによって、ほぼ任意の入力を処理できます。

** まとめ

[[https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-State-Strict.html][=Stete=]] モナドを作って簡易パーサを作成しました。初めて他の競技者がパーサの合成しているのを見たときは、かなりぐっと来たのを覚えています。実際に使用してみると、格好良さと実用性が両立したスタイルだと思います。

なおライブラリとしては、パーサ (=*P=) に [[https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-State-Class.html#t:MonadState][=MonadState=]] を使ったほうが良さそうです。たとえば標準入力全体を =Stete= モナドに載せておけば、 =withLine= などを経由せず、直にパーサを呼び出しできるようになります。

#+BEGIN_SRC haskell
main :: IO ()
main = evalStateT main' =<< BS.getContents
#+END_SRC

* 全てからの脱出
:PROPERTIES:
:EXPORT_FILE_NAME: cont-t
:END:

** ああああ

もう、止めたい。この世の全てから逃れたい。

そんなとき、我々は大域脱出します。

** 継続モナド (=Cont= モナド)

=transfomer= の [[https://hackage.haskell.org/package/transformers-0.6.1.2/docs/Control-Monad-Trans-Cont.html][=Control.Monad.Trans.Cont=]] は僅か 250 行。リッチなソース解説も、ございます！　ありがとうございます！

#+BEGIN_EXPORT html
https://qiita.com/sparklingbaby/items/2eacabb4be93b9b64755
#+END_EXPORT

*** =callCC= の使い方

=callCC= の仕組みは理解できていないのですが、試しに使用してみます。たとえば $2^n \ge x$ を満たす $2^n$ を求める関数があります:

#+BEGIN_SRC hs
-- >>> calc1 14
-- 16
calc1 :: Int -> Int
calc1 x0 = until (>= x0) (* 2) (1 :: Int)
#+END_SRC

これを Rust で手続き的に実装すればこんな形で:

#+BEGIN_SRC rust
fn calc_2(x0: usize) -> usize {
    let mut x = x0;
    while x < x0 {
        x *= 2;
    }
    x
}
#+END_SRC

=Cont= を使って手続き的な実装にすれば以下の通り。 =exit= を呼べば脱出できます:

#+BEGIN_SRC hs
calc2 :: Int -> Int
calc2 x0 = evalCont $ callCC $ \exit ->
  flip fix (1 :: Int) $ \loop acc -> do
    when (acc >= x0) $
      exit acc
    loop (acc * 2)
#+END_SRC

無駄に =ContT= を使って =Stete= モナドに返値を載せると、次のようになります:

#+BEGIN_SRC hs
calc2' :: Int -> Int
calc2' x0 = (`execState` (1 :: Int)) $ evalContT $ callCC $ \exit -> do
  fix $ \loop -> do
    acc <- get
    when (acc >= x0) $
      exit ()
    put (2 * acc)
    loop
#+END_SRC

なお =lift= は基本必要ありません。

- [[https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Cont.html#t:MonadCont][=MonadCont=]] は =StateT= に対して実装されています。
- [[https://hackage.haskell.org/package/primitive-0.9.0.0/docs/Control-Monad-Primitive.html][=PrimMonad=]] でも =PrimMonad m => PrimMonad (ContT r m)= が提供されており、たとえば =ContT () (ST s)= は =PrimMonad= を実装します。

** =callCC= が活きる問題

たとえば [[https://atcoder.jp/contests/abc345/tasks/abc345_d][ABC 345 - D]] で大域脱出が大活躍します。継続モナドを使用した場合、コードは /比較的/ 整理がつきましたが、実行速度は約 3 倍になりました。

- [[https://atcoder.jp/contests/abc345/submissions/51371574][継続モナド使用前 (91 ms)]]
- [[https://atcoder.jp/contests/abc345/submissions/51521918][継続モナド使用時 (281 ms)]]

[[https://atcoder.jp/contests/abc345/submissions/51403780][cojna さんの提出]] は 60 ms です。 =callCC= を使っていますが、めちゃめちゃ速い！　=ContT= の使い方は、この提出から学ばせてもらいました。ありがとうございます。

** まとめ

Haskell では関数から =return= できませんが、大域脱出はできます。この辺りは Lisp とも類似しており、他言語習得にも役立ちそうです。

また =callCC= に限らず継続モナドは大活躍するようです。まだまだ遊べます。

#+BEGIN_EXPORT html
https://takoeight0821.hatenablog.jp/entry/2024/03/12/150448
#+END_EXPORT

* Assert 文の共通化
:PROPERTIES:
:EXPORT_FILE_NAME: assert
:END:

** =check= シリーズ

[[=ac-library-hs=][=ac-library-hs=]] では、添字境界チェックの関数を作成しました:

#+BEGIN_SRC haskell
{-# INLINE checkIndex #-}
checkIndex :: (HasCallStack) => String -> Int -> Int -> ()
checkIndex funcName i n
  | 0 <= i && i < n = ()
  | otherwise = error $ funcName ++ ": given invalid index `" ++ show i ++ "` over length `" ++ show n ++ "`"
#+END_SRC

[[https://qiita.com/mod_poppo/items/b3b415ea72eee210d222][Haskellのassertを文っぽく使う]] の精神で、次のように使用できます:

#+BEGIN_SRC haskell
merge :: (HasCallStack, PrimMonad m) => Dsu (PrimState m) -> Int -> Int -> m Int
merge dsu@Dsu {..} a b = stToPrim $ do
  let !_ = ACIA.checkVertex "AtCoder.Dsu.merge" a nDsu
  let !_ = ACIA.checkVertex "AtCoder.Dsu.merge" b nDsu
  -- ~~
#+END_SRC

これで多くのコードを集約し、エラー文の品質も担保できました。実行効率もそんなに悪くありません。良いことづくめ……と、本当にこれで良かったでしょうか。

*** 部分関数を許容すべきか

最近試した [[https://www.purescript.org/][PureScript]] では、大まかに言って部分関数が禁止されていました。部分関数を書いた場合は [[https://pursuit.purescript.org/packages/purescript-partial/1.2.0/docs/Partial.Unsafe#v:unsafePartial][=unsafePartial=]] 越しに呼ぶことになるため、 +屈辱です+ 代わりに =Maybe= や =Either= を使った全域関数が主になります。

一方 Haskell では部分関数が書き放題です。 [[=ac-library-hs=][=ac-library-hs=]] も、 /比較的/ ACL に忠実なライブラリであるとして、部分関数を主に据えてリリース予定でした。しかし今一度全域関数を検討します。競プロ用ライブラリとしての手軽さと、全域関数の便利さを両取りすれば良さそうです。

*** test, error, assert を分ける

お手本として =vector= パッケージを参照します。やはり [[https://hackage.haskell.org/package/vector-0.13.2.0/docs/Data-Vector-Generic-Mutable.html#v:readMaybe][=readMaybe=]] のように、全域関数も用意するのが無難な線です。上の =merge= の例では、次のように 3 つの関数に分けたいです:

#+BEGIN_SRC haskell
merge :: (HasCallStack, PrimMonad m) => Dsu (PrimState m) -> Int -> Int -> m Int
merge dsu a b
  | not (testIndex a nDsu) = errorIndex a nDsu
  | not (testIndex b nDsu) = errorIndex b nDsu
  | otherwise = unsafeMerge dsu a b

mergeMaybe :: (HasCallStack, PrimMonad m) => Dsu (PrimState m) -> Int -> Int -> m (Maybe Int)
mergeMaybe dsu a b
  | not (testIndex a nDsu) = pure Nothing
  | not (testIndex b nDsu) = pure Nothing
  | otherwise = Just <$> unsafeMerge dsu a b

mergeMaybe :: (HasCallStack, PrimMonad m) => Dsu (PrimState m) -> Int -> Int -> m Int
mergeMaybe dsu a b = { .. }
#+END_SRC

必然的に、 =checkIndex= (assertion) も =checkIndex=, =testIndex=, =errorIndex= に分かれます。単純な例ではありますが、こうした構造の整理が盆栽の醍醐味だと思います:

#+BEGIN_SRC haskell
{-# INLINE checkIndex #-}
checkIndex :: (HasCallStack) => String -> Int -> Int -> ()
checkIndex funcName i n
  | testIndex i n = ()
  | otherwise = errorIndex funcName i n

{-# INLINE testIndex #-}
testIndex :: (HasCallStack) => Int -> Int -> Bool
testIndex i n = 0 <= i && i < n

{-# INLINE errorIndex #-}
errorIndex :: (HasCallStack) => String -> Int -> Int -> ()
errorIndex funcName i n =
  error $ funcName ++ ": given invalid index `" ++ show i ++ "` over length `" ++ show n ++ "`"
#+END_SRC

競プロ縛りだと普通の Haskell プログラミングに飢えてきて、普通のプログラミングを『盆栽』と称している可能性はあります。

*** 本当に全域関数を追加するのか

部分関数を 3 つの関数 (部分関数、全域関数、 unsafe 関数) に分けて行くと、ドキュメントが分厚くなるのが嫌です。 =vector= パッケージにおいても、 =exchange= や =modify= などには全域関数がありません。用途が少ない関数は省略して良さそうです。

重要な全域関数のみを追加してみます。経験上、区間取得がよくエラーになるため、セグメント木の =prod= 関数などを対象に =*Maybe= シリーズを作ります。他は随時検討します。

それにしても、自分の作ったライブラリが PureScript 的に出来損ないだと思うのは悲しいです。いずれ全域関数縛りのお作法も学ばなければなりませんね。

** [[https://github.com/sol/doctest][=doctest=]] の実施

統一したエラー文に間違いが無いか確認します。 Haskell には builtin の string interpolation が無く、空白の有無などでミスが起きやすいです。

[[https://github.com/sol/doctest][doctest]] を書いてメッセージ内容を確認します。

#+BEGIN_SRC haskell
-- >>> let !_ = checkIndex "AtCoder.Internal.Assert.doctest" (-1) 3
-- *** Exception: AtCoder.Internal.Assert.doctest: given invalid index `-1` over length `3`
-- ...
#+END_SRC

実際のエラー文にはスタックトレースが続きますが、 =...= とマッチさせることで [[https://github.com/sol/doctest][=doctest=]] を通過します ([[https://github.com/sol/doctest?tab=readme-ov-file#matching-arbitrary-output][Matching arbitrary input]]) 。こうしてエラーケースも [[https://github.com/sol/doctest][=doctest=]] できました。

*** [[https://github.com/sol/doctest][=doctest=]] の実行方法

**** 1. REPL からの実行

プロジェクト全体の [[https://github.com/sol/doctest][=doctest=]] は REPL から実施するのが無難です。

#+BEGIN_SRC sh
$ cabal repl --with-ghc=doctest --repl-options='-w -Wdefault'
#+END_SRC

#+BEGIN_QUOTE
[[https://hackage.haskell.org/package/QuickCheck][=QuickCheck=]] 付きの =doctest= ([[https://github.com/sol/doctest?tab=readme-ov-file#quickcheck-properties][=prop>=]]) を使う場合は、依存指定が必要かもしれません。
#+END_QUOTE

**** 2. =stack test= からの実行

=stack test= からも [[https://github.com/sol/doctest][=doctest=]] を実施できたはずです。

#+BEGIN_SRC haskell
main :: IO ()
main = do
  -- Run `doctest` over all the source files:
  doctest ["-isrc", "src/"]
#+END_SRC

=cabal test= からの実行は、色々大変そうで諦めました ([[https://github.com/toyboot4e/ac-library-hs/issues/19][#19]]) 。どうも =Setup.hs= が必要な雰囲気です。

**** 3. HLS による実行

[[https://zenn.dev/jij_inc/articles/2024-12-18-pure-haskeller-writing-rust][Haskeller の異常な愛情]] を読んで知ったことですが、 [[https://github.com/haskell/haskell-language-server/blob/master/plugins/hls-eval-plugin][HLS の eval plugin]] によって [[https://github.com/sol/doctest][=doctest=]] を評価できます。たとえば次の =doctest= を作成します。

#+BEGIN_SRC haskell
-- | My function.
--
-- >>> let g = (* 3)
-- >>> 1
--
-- >>> g $ f 1
f :: Int -> Int
f = (* 2)
#+END_SRC

僕のエディタ上では以下のように code lens が表示します。現状、 [[https://github.com/haskell/haskell-language-server/issues/496][eval plugin の code action が無い]] そうなので、 code lens を有効化しましょう。僕は無効化していて気づきませんでした……:

#+BEGIN_EXPORT markdown
![Emacs](/images/kyopro-bonsai-hs/hls-eval-1.png =269x)
*Emacs*
#+END_EXPORT

Evaluate をクリックすると、次のように =doctest= の評価結果が表示します。

#+BEGIN_SRC haskell
-- | My function.
--
-- >>> let g = (* 3)
-- >>> 1
-- 1
--
-- >>> g $ f 1
-- 6
f :: Int -> Int
f = (* 2)
#+END_SRC

初回の =doctest= は HLS の eval plugin で結果を生成し、以降は =cabal repl= から実施すれば良いと思います。

*** 備考: =.cabal/bin/= の自動切り替え

=cabal install= したコマンドは、デフォルトだと =~/.cabal/bin= 以下に保存されます。おそらく GHC のバージョン切り替えが考慮されていません。特に =doctest= は GHC のバージョンごとにビルドする必要があるため、 GHC と共に自動で切り替わってほしいと思います。

[[https://github.com/haskell/ghcup-hs][=ghcup=]] ユーザは、 GHC のバージョン毎に =bin= フォルダが自動で切り替わると思います (未確認) 。たぶん問題ありません。

[[https://nixos.org/][Nix]] では =cabal install= を手動実行する必要は無く、 =devShell= でバージョン指定すれば [[https://github.com/nix-community/nix-direnv][=nix-direnv=]] により自動で =PATH= に入ります。恐ろしく手間のかかったエコシステムです。

#+BEGIN_SRC nix
(haskell.compiler.ghc983.override { useLLVM = true; })
(haskell-language-server.override { supportedGhcVersions = [ "983" ]; })
haskell.packages.ghc983.cabal-fmt
haskell.packages.ghc983.cabal-plan
haskell.packages.ghc983.doctest
haskell.packages.ghc983.implicit-hie
#+END_SRC

入れたコマンドは以下の 4 つです:

#+BEGIN_EXPORT markdown
1. [cabal-fmt](https://github.com/phadej/cabal-fmt)
  `cabal-fmt -i ac-library-hs.cabal` のようにフォーマットできます。
1. [cabal-plan](https://github.com/haskell-hvr/cabal-plan)
  `cabal-plan info` で今使っているパッケージのバージョン確認などができます。
1. [`doctest`](https://github.com/sol/doctest)
  `cabal repl --with-ghc=doctest` で `doctest` を実施できます。
1. [`implicit-hie`](https://github.com/Avi-D-coder/implicit-hie)
  `gen-hie > hie.yaml` を実行して初めて HLS が動作する場合があります。
#+END_EXPORT

*** おまけ: [[https://github.com/haskell/cabal/issues/1179][すべての警告を表示する]] には

以下のコマンドが (比較的) 速いようです。

#+BEGIN_SRC sh
$ cabal build --ghc-options="-fforce-recomp -fno-code"
#+END_SRC

** Goldten test (snapshots test)

Rust の [[https://docs.rs/insta/latest/insta/][insta]] クレートは、テストプログラムの標準出力をファイル保存しておき、再実行時に diff が見れるライブラリです。 Snapshots test を名乗っています。自作言語の作成時には、構文木の pretty printer などと組み合わせて重宝するようです。

Haskell 界隈で snapshots test は [[https://ro-che.info/articles/2017-12-04-golden-tests][golden test]] として知られています。今回の =checkIndex= 関数のテストは [[https://github.com/sol/doctest][=doctest=]] で十分だったため試していません ([[https://github.com/toyboot4e/ac-library-hs/issues/17][#17]]) が、利用機会が楽しみです。

* インクリメンタルな開発
:PROPERTIES:
:EXPORT_FILE_NAME: incremental-development
:END:

** テストが欲しい

[[=ac-library-hs=][=ac-library-hs=]] の開発は、言ってしまえばただの写経です。本家 [[https://github.com/atcoder/ac-library][=ac-library=]] のコードを右から左へ書き写すだけ。楽勝でした！

色々バグが出て大変でした。特に酷かったのは最小費用流で、大きな関数を何度も一から読み直しました。デバッグに一週間かかり、 *先にテストを書くべきだった* と痛感しました。しかも馬鹿らしくなるほど単純なもので十分でした。

** [[https://github.com/UnkindPartition/tasty][=tasty=]] のセットアップ

Haskell のテストフレームワークは [[https://github.com/UnkindPartition/tasty][=tasty=]] が主流と思います。 2013 年当時は [[https://blog.ocharles.org.uk/posts/2013-12-03-24-days-of-hackage-tasty.html][=test-framework= が普及していた]] ようですが、メンテナンス困難になり [[https://github.com/UnkindPartition/tasty][=tasty=]] が生まれたとか。

[[https://github.com/UnkindPartition/tasty][=tasty=]] は Haskell 界では珍しく README が充実しています。ツールはドキュメント性で選べば間違い無いと思いますから、 [[https://github.com/UnkindPartition/tasty][=tasty=]] には安心感があります。開発者ブログも面白い。

*** =ac-library-hs.cabal=

=test-suite= を追加しました。どうも *=cabal= 自身に =test-suite= などのエントリーを追加するコマンドが無さそう* で、手動でコピペしました。こういうのは手書きしたくないものですが:

#+BEGIN_SRC yaml
test-suite ac-library-hs-test
  import:         warnings
  import:         dependencies
  other-modules:
    Tests.Internal.MinHeap

  type:           exitcode-stdio-1.0
  hs-source-dirs: test
  main-is:        Main.hs
  build-depends:
    , ac-library-hs
    , hspec
    , mtl
    , QuickCheck
    , quickcheck-classes
    , random
    , tasty
    , tasty-hspec
    , tasty-hunit
    , tasty-quickcheck
    , tasty-rerun
    , transformers
#+END_SRC

*** =tests/Main.hs=

=Main.hs= は [[https://github.com/ocharles/tasty-rerun][=tasty-rerun=]] を使う形にしました:

#+BEGIN_SRC haskell
module Main (main) where

import Test.Tasty (testGroup)
import Test.Tasty.Ingredients.Rerun
import Tests.Internal.MinHeap qualified

main :: IO ()
main =
  defaultMainWithRerun
    . testGroup "toplevel"
    $ [ testGroup "Tests.Internal.MinHeap" Tests.Internal.MinHeap.tests,
      ]
#+END_SRC

*** =tests/Internal/MinHeap.hs=

ここで作成したテストは、自作の =MinHeap= が本当に昇順で値を取り出すかを確認します:

#+BEGIN_SRC haskell
module Tests.Internal.MinHeap (tests) where

import AtCoder.Internal.MinHeap qualified as ACIMH
import Control.Monad
import Control.Monad.ST (runST)
import Data.Foldable (for_)
import Data.List qualified as L
import Data.Maybe (fromJust)
import Test.Tasty
import Test.Tasty.QuickCheck qualified as QC

prop_ordered :: [Int] -> Bool
prop_ordered xs =
  let n = length xs
      expected = L.sort xs
      result = runST $ do
        -- ヒープを作成する
        heap <- ACIMH.new n
        for_ xs (ACIMH.push heap)
        -- ヒープから順番に値を取り出す
        replicateM n (fromJust <$> ACIMH.pop heap)
   in expected == result

tests :: [TestTree]
tests =
  [ QC.testProperty "min heap ordering" prop_ordered
  ]
#+END_SRC

この単純なテストに失敗し、実は最小費用流ではなく =MinHeap= にバグがあると分かりました。これで数日潰れたのは悲しいです。以降のモジュールは、先に簡単なテストを書いてから作成しました。

*** テスト実行

[[https://github.com/ocharles/tasty-rerun][=tasty-rerun=]] による実行のため、オプションを指定しています。前回のテストで失敗したテストがあった場合は、失敗したテストのみ再実行できます:

#+BEGIN_SRC sh
$ cabal test --test-option --rerun
#+END_SRC

毎回オプションを指定するのは手間で、シェルスクリプトにして置いています。

> [[https://github.com/casey/just][=just=]] か [[https://github.com/sagiegurari/cargo-make][=cargo-make=]] のようなタスクランナーを導入した方が良いかもしれません。コミュニティでどんどん質問して行きたいです。

** 各種テストの作成

[[https://github.com/UnkindPartition/tasty][=tasty=]] により各種テストライブラリを =TestTree= にまとめて一括実行できます。 [[https://github.com/haskell-works/tasty-discover][=tasty-discorver=]] に [[https://github.com/haskell-works/tasty-discover?tab=readme-ov-file#write-tests][記載がある]] 通り、テスト関数名に接頭辞を付けると (Template Haskell により) すべてのテストを実行する仕組みがあります。

#+BEGIN_EXPORT markdown
> - prop_: [QuickCheck](http://hackage.haskell.org/package/tasty-quickcheck) properties.
> - scprop_: [SmallCheck](http://hackage.haskell.org/package/tasty-smallcheck) properties.
> - hprop_: [Hedgehog](http://hackage.haskell.org/package/tasty-hedgehog) properties.
> - unit_: [HUnit](http://hackage.haskell.org/package/tasty-hunit) test cases.
> - spec_: [Hspec](http://hackage.haskell.org/package/tasty-hspec) specifications.
> - test_: [Tasty](http://hackage.haskell.org/package/tasty) TestTrees.
> - tasty_: Custom tests
#+END_EXPORT

[[=ac-library-hs=][=ac-library-hs=]] ではテストの一覧を手書きしていますが、テスト名には慣習通り接頭辞を付けました。

*** [[https://hackage.haskell.org/package/tasty-hunit][=tasty-hunit=]]

[[https://hackage.haskell.org/package/HUnit][=hunit=]] は僅か 739 行の単体テストのライブラリです。主に =assert= 相当の関数と演算子を提供します。 [[https://hackage.haskell.org/package/tasty-hunit][=tasty-hunit=]] が本家 [[https://hackage.haskell.org/package/HUnit][=hunit=]] の内容を re-export しているため、 [[https://hackage.haskell.org/package/tasty-hunit][=tasty-hunit=]] のみを見れば良いと思います。

[[https://github.com/atcoder/ac-library][=ac-library=]] (C++) の単体テストは assertion であるため、主に [[https://hackage.haskell.org/package/tasty-hunit][=tasty-hunit=]] で移植しました。 [[https://hackage.haskell.org/package/tasty-hunit-0.10.2/docs/Test-Tasty-HUnit.html#v:-64--63--61-][~@=?~]] の使用頻度が高かったです。

#+BEGIN_SRC haskell
module Tests.Dsu (tests) where

import AtCoder.Dsu qualified as Dsu
import Test.Tasty
import Test.Tasty.HUnit

unit_simple :: TestTree
unit_simple = testCase "simple" $ do
  uf <- Dsu.new 2
  (@?= False) =<< Dsu.same uf 0 1
  x <- Dsu.merge uf 0 1
  (@?= True) =<< Dsu.same uf 0 1

tests :: [TestTree]
tests =
  [ unit_simple
  ]
#+END_SRC

[[https://hackage.haskell.org/package/HUnit][=hunit=]] はテスト用ライブラリとしては小さ過ぎます。たとえば [[https://hackage.haskell.org/package/tasty-hunit-0.10.2/docs/Test-Tasty-HUnit.html#v:assertEqual][=assertEqual=]] があって =assertNotEqual= はありません。また例外発生を予期したテストを書く仕組みもありません。そのため [[https://hspec.github.io/hunit.html][=hunit= の上に作られた]] という [[https://hackage.haskell.org/package/hspec][=hspec=]] も使います。

*** [[https://hackage.haskell.org/package/hspec][=hspec=]], [[https://hackage.haskell.org/package/tasty-hspec][=tasty-hspec=]]

=hspec-*= パッケージを色々集めると 15,000 行くらいあります。独特の記法に面食らいましたが、 [[https://hackage.haskell.org/package/hspec][=hspec=]] は [[https://www.mew.org/~kazu/material/2012-bdd.pdf][BBD (behavior driven development) のライブラリ]] らしく、きっとメジャーな API です。

ここでは例外発生のテストを書いてみます:

#+BEGIN_SRC haskell
module Tests.Dsu (tests) where

import AtCoder.Dsu qualified as Dsu
import System.IO.Unsafe (unsafePerformIO)
import Test.Hspec
import Test.Tasty
import Test.Tasty.Hspec

spec_invalid :: IO TestTree
spec_invalid = testSpec "invalid" $ do
  -- it throws error と読める (behaviour を説明している)
  it "throws error" $ do
    Dsu.new (-1) `shouldThrow` anyException

tests :: [TestTree]
tests =
  [ unsafePerformIO spec_invalid
  ]
#+END_SRC

[[https://hackage.haskell.org/package/tasty-hspec-1.2.0.4/docs/Test-Tasty-Hspec.html#g:3][Examples]] にある通り、ここでの =unsafePerformIO= には他のテストへの副作用が無いため、 =perfectly fine= です。もう少しシンプルに =TestTree= に組み込めないかという気はしますが……。また使い方の割に依存が大きかったため、 =hunit= に合わせて =assertException= のような関数を作るだけでも良かった気はします。

*** [[https://hackage.haskell.org/package/QuickCheck][=QuickCheck=]], [[https://hackage.haskell.org/package/tasty-quickcheck-0.11][=tasty-quickcheck=]]

我らが [[https://x.com/xuzijian629/status/1222056854978617345][† 伝家の宝刀 †]] 、 7,114 行の PBT (プロパティベーステスト) のライブラリです。大きめのライブラリですが、 API はそこまで大きくなく、逆に機能不足を感じるときもあります。

僕は [[https://www.lambdanote.com/products/proper][実践プロパティベーステスト]] を 1/3 まで読んで積んでいますが、身構えず、ラフなテストを書くために使ってみました。実例は =MinHeap= の例の通りですが、その他便利な使い方をメモしておきます。

**** =Bool= を返す関数は [[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#t:Testable][=Testable=]]

自明なテストは =Bool= を返す関数で十分だと思います。ここでは失敗ケースを見たいので、滅茶苦茶なプロパティを書いてみます。

#+BEGIN_SRC haskell
import Test.Tasty
import Test.Tasty.QuickCheck qualified as QC

prop_example :: [Int] -> Bool
prop_example xs = xs == reverse xs

tests :: [TestTree]
tests =
  [ QC.testProperty "example" prop_example,
  ]
#+END_SRC

当然失敗します。ここで入力値が表示されますが、 **左辺と右辺の値が表示されません** 。改善します。

#+BEGIN_SRC sh
example: FAIL
  ,*** Failed! Falsified (after 3 tests and 1 shrink):
  [1,0]
  Use --quickcheck-replay="(SMGen 15558177999669110064 7725842824357830847,2)" to reproduce.

1 out of 1 tests failed (0.00s)
#+END_SRC

#+BEGIN_QUOTE
なお verbose check にすれば通過ケースや shrink の過程も確認できます。 QuickCheck を読む時は shrink 周辺が見どころですね。

#+BEGIN_SRC sh
$ cabal test --test-options '--quickcheck-verbose'
example: FAIL
  Passed:
  []

  Failed:
  [2,2,1]

  Passed:
  []

  Failed:
  [2,1]
..
#+END_SRC
#+END_QUOTE

**** エラー表示を詳細に

テスト失敗時のカスタムメッセージを指定する関数が [[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#v:counterexample][=counterexample=]]  です。判例 (counterexample) の詳細を表示するということですね:

#+BEGIN_SRC haskell
prop_example :: [Int] -> QC.Property
prop_example xs = QC.counterexample "error case" $ xs == reverse xs
#+END_SRC

エラーメッセージに =error case= が追加されました:

#+BEGIN_SRC haskell
example: FAIL
  ,*** Failed! Falsified (after 4 tests and 2 shrinks):
  [0,1]
  error case
  Use --quickcheck-replay="(SMGen 7441833134974059469 3200274122949544035,3)" to reproduce.

1 out of 1 tests failed (0.00s)
#+END_SRC

[[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#v:-61--61--61-][~===~]] や [[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#v:-61--47--61-][~=/=~]] も [[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#v:counterexample][=counterexample=]] を使って実装されています。失敗時に左辺と右辺の値を表示してくれるようになります:

#+BEGIN_SRC haskell
(===) :: (Eq a, Show a) => a -> a -> Property
x === y =
  counterexample (show x ++ interpret res ++ show y) res
  where
    res = x == y
    interpret True  = " == "
    interpret False = " /= "
#+END_SRC

[[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#v:-61--61--61-][~===~]] を使うと、次のようなエラー表示になります:

#+BEGIN_SRC haskell
prop_example :: [Int] -> QC.Property
prop_example xs = xs QC.=== reverse xs
#+END_SRC

#+BEGIN_SRC sh
example: FAIL
  *** Failed! Falsified (after 6 tests and 6 shrinks):
  [0,1]
  [0,1] /= [1,0]
  Use --quickcheck-replay="(SMGen 16394814400549318447 147282775057894905,5)" to reproduce.

1 out of 1 tests failed (0.00s)
#+END_SRC

欲を言えば、両辺の計算式をそれぞれテキストで表示して、何の式を比較したか一目で確認したいところです。これは『モノイドのテスト』で実施します。

**** [[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#t:Gen][=Gen=]] モナド

[[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#t:Arbitrary][=Arbitrary=]] 型の引数は規定の [[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#t:Gen][=Gen=]] により生成されますが、手動で =Gen= を使うこともできます:

#+BEGIN_SRC haskell
prop_example :: QC.Property
prop_example = do
  QC.forAll (QC.arbitrary @Int) $ \n ->
    QC.forAll (QC.vectorOf n (QC.arbitrary @Int)) $ \xs ->
      xs QC.=== reverse xs
#+END_SRC

[[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#v:forAll][=forAll=]] でも悪くないですが、 [[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck.html#t:Gen][=Gen=]] モナドの bind (=<-=) を使えばフラットに記述できます:

#+BEGIN_SRC haskell
prop_example :: QC.Gen QC.Property
prop_example = do
  n <- QC.arbitrary @Int
  xs <- QC.vectorOf n (QC.arbitrary @Int)
  pure $ xs QC.=== reverse xs
#+END_SRC

実行するとこうなりました:

#+BEGIN_SRC txt
example: FAIL
  ,*** Failed! Falsified (after 2 tests):
  [-1,-1,-1,1,0,0] /= [0,0,1,-1,-1,-1]
  Use --quickcheck-replay="(SMGen 15437984156035230625 5370423934061024679,1)" to reproduce.

1 out of 1 tests failed (0.00s)
#+END_SRC

Shrinking が起きませんでした。 =Gen= の使い方には注意が必要そうです。

**** =Arbitrary= の orphan instance

=Max=, =Sum=, =ByteString=, =Vector= 等々には =Arbitrary= インスタンスが定義されていません。都度自分で (orphan) instance を定義するか、 [[https://hackage.haskell.org/package/quickcheck-instances][quickcheck-instances]] パッケージを利用すると良さそうです。

**** =Monadic= なテスト

=MinHeap= の例では =ST= モナドを使用しましたが、 monadic な計算過程で常に invariant が成り立つか確認したいとき、手軽にテストしたい時などは [[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck-Monadic.html][=Test.QuickCheck.Monadic=]] が使えます。 Mutable データ型のテストにも利用できます。

=Gen= の利用には [[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck-Monadic.html#v:forAllM][=forAllM=]] を使うか、 [[https://hackage.haskell.org/package/QuickCheck-2.15.0.1/docs/Test-QuickCheck-Monadic.html#v:pick][=pick=]] を使うとフラットにできます。以下では最小費用流の CSR で順方向・逆方向の辺の頂点が互いに逆向きであるか確認しています:

#+BEGIN_SRC haskell
module Tests.Internal.McfCsr (tests) where

import AtCoder.Internal.McfCsr qualified as ACIMCSR
import Data.Foldable
import Data.Vector.Unboxed qualified as VU
import Test.QuickCheck.Monadic qualified as QC
import Test.Tasty
import Test.Tasty.QuickCheck qualified as QC

-- 最小費用流の辺を生成する
edgeGen :: Int -> Int -> QC.Gen [(Int, Int, Int, Int, Int)]
edgeGen n m = QC.vectorOf m $ do
  from <- QC.chooseInt (0, n - 1)
  to <- QC.chooseInt (0, n - 1)
  cap <- QC.chooseInt (0, 16)
  flow <- QC.chooseInt (0, cap)
  cost <- QC.chooseInt (0, 16)
  pure (from, to, cap, flow, cost)

-- 最小費用流の CSR で順方向・逆方向の辺が互いに逆向きであるか確認する
revEdgeDirection :: Int -> Int -> QC.Property
revEdgeDirection n m = QC.monadicIO $ do
  -- 辺の数と頂点の数を決める
  n <- QC.pick $ QC.chooseInt (1, 16)
  m <- QC.pick $ QC.chooseInt (0, 128)
  -- 辺を生成する
  edges <- QC.pick $ edgeGen n m
  -- グラフを生成する
  (!_, csr@ACIMCSR.Csr {..}) <- QC.run $ ACIMCSR.build n (VU.fromList edges)
  -- 辺の向きをチェックする
  for_ [0 .. n - 1] $ \from -> do
    VU.forM_ (ACIMCSR.adj csr from) $ \(!_to, !rev, !cost) -> do
      QC.assert $ toCsr VU.! rev == from
      QC.assert $ -costCsr VU.! rev == cost
#+END_SRC

*** 特定のテストを実行する

=TestTree= の中の特定のテストを実行するため、 =tasty= の [[https://github.com/UnkindPartition/tasty?tab=readme-ov-file#patterns][patterns]] を利用します。開発者ブログ ([[https://ro-che.info/articles/2018-01-08-tasty-new-patterns][New patterns in tasty]]) にあるとおり、 =tasty= の [[https://github.com/UnkindPartition/tasty?tab=readme-ov-file#patterns][patterns]] は AWK のアイデアが元になっています。

AWK と聞いただけで、すべてを理解されたかもしれません。まずテストの一覧を =tasty= の [[https://github.com/UnkindPartition/tasty?tab=readme-ov-file#runtime][=-l=]] オプションで確認します:

#+BEGIN_SRC text
$ cabal test --test-options '-l'
toplevel.Convolution.empty
toplevel.Convolution.butterfly
#+END_SRC

プログラム上は次の関係にあり、 /group/ 名が =.= で区切られていることが分かります:

#+BEGIN_SRC haskell
main :: IO ()
main =
  defaultMainWithRerun
    . testGroup "toplevel"
    $ [ testGroup "Convolution"
        [ unit_empty,
          unit_butterfly
        ]
      ]

unit_empty :: TestTree
unit_empty = testCase "empty" $ do
  VU.empty @=? ACC.convolutionRaw (Proxy @998244353) (VU.empty @Int) (VU.empty @Int)

unit_butterfly :: TestTree
unit_butterfly = testCase "butterfly" $ do {.. }
#+END_SRC

=empty= テストのみ実施する方法としては、以下のパターンなどがあります:

#+BEGIN_SRC sh
$ cabal test --test-option '-p $NF=="empty'"
Test suite ac-library-hs-test: RUNNING...
toplevel
  Convolution
    empty: OK
  Scc
    empty: OK
  String
    empty: OK
  TwoSat
    empty: OK

All 4 tests passed (0.00s)
#+END_SRC

#+BEGIN_SRC sh
$ cabal test --test-option '-p /empty/'
Test suite ac-library-hs-test: RUNNING...
toplevel
  Convolution
    empty: OK
  Scc
    empty: OK
  String
    empty: OK
  TwoSat
    empty: OK

All 4 tests passed (0.00s)
#+END_SRC

=Convolution.empty= テストのみ実施する方法としては、以下のパターンなどがあります:

#+BEGIN_SRC sh
$ cabal test --test-option '-p $0=="toplevel.Convolution.empty"'
Running 1 test suites...
Test suite ac-library-hs-test: RUNNING...
toplevel
  Convolution
    empty: OK

All 1 tests passed (0.00s)
#+END_SRC

#+BEGIN_SRC sh
$ cabal test --test-option '-p $2=="Convolution" && $3=="empty"'
Running 1 test suites...
Test suite ac-library-hs-test: RUNNING...
toplevel
  Convolution
    empty: OK

All 1 tests passed (0.00s)
#+END_SRC

#+BEGIN_QUOTE
ところで =--test-options= にすると、エラーが出ます:

#+BEGIN_SRC sh
$ cabal test --test-options '-p $NF=="empty'"
...
option -p: Could not parse: $NF==toplevel.Convolution.empty is not a valid pattern
#+END_SRC

どうも =cabal= による単語分解で ="= が消えるようです。 =cabal= の引数はめんどくさいぞ〜
#+END_QUOTE

一応、 [[https://github.com/ocharles/tasty-rerun][=tasty-rerun=]] との併せ技もできます:

#+BEGIN_SRC sh
$ cabal test --test-options '--rerun -p /empty/'
Running 1 test suites...
Test suite ac-library-hs-test: RUNNING...
toplevel
  Convolution
    empty: FAIL
      test/Tests/Convolution.hs:62:
      expected: False
       but got: True
      Use -p '/empty/&&/Convolution.empty/' to rerun this test only.
  Scc
    empty: OK
  String
    empty: OK
  TwoSat
    empty: OK

1 out of 4 tests failed (0.00s)
Test suite ac-library-hs-test: FAIL

$ cabal test --test-options '--rerun -p empty'                                                                                                                                          ✘ 1 wip ⬆ ✚ ✱ ◼
Running 1 test suites...
Test suite ac-library-hs-test: RUNNING...
toplevel
  Convolution
    empty: FAIL
      test/Tests/Convolution.hs:62:
      expected: False
       but got: True

1 out of 1 tests failed (0.00s)
Test suite ac-library-hs-test: FAIL
#+END_SRC

** まとめ

[[=ac-library-hs=][=ac-library-hs=]] の開発経験から、テストを書く必要性を実感しました。テストのカバレッジが 100% である必要は無く、 QuickCheck で雑なテストを書くだけで十分に開発を高速化できます。境界値チェックや網羅的なテストは =hunit= や =hspec= で assert を書けば良いと思います。

* モノイドのテスト
:PROPERTIES:
:EXPORT_FILE_NAME: monoid-check
:END:

** 頻出バグ

遅延伝播セグメント木の問題では、以下の性質を満たす 2 種類のモノイド $F, X$ を定義します。

1. モノイド作用: $(f_2 \circ f1) * x = f_2 * (f1 * x)$
2. 恒等写像: $f^0 * x = x$
3. 自己同型写像: $f (x1 \cdot x2) = (f * x1) \cdot (f * x2)$

#+BEGIN_QUOTE
[[https://en.wikipedia.org/wiki/Semigroup_action#Formal_definitions][半群作用の wiki]] を参考に見様見真似で書いてみました。不正確でしたらすみません。
#+END_QUOTE

*** Haskell における表記法

[[=ac-library-hs=][=ac-library-hs=]] では以下の形に落とし込みました。

| 数式    | Haskell       |
|---------+---------------|
| $\circ$ | =(<>) @f=      |
| $\cdot$ | =(<>) @a=    |
| $f^0$  | =mempty @f=  |
| $*$     | 以下の =segAct= |

#+BEGIN_SRC haskell
class (Monoid f) => SegAct f a where
  segAct :: f -> a -> a
#+END_SRC

上記の 3 つの性質をコードにすれば、以下の性質を満たす必要があります:

1. ~(f2 <> f1) `segAct` x == f2 `segAct` (f1 `segAct` x)~
2. ~(mempty @f) `segAct` x == x~
3. ~f `segAct` (x2 <> x1) == (f `segAct` x2) <> (f `segAct` x1)~

この性質を破ってしまったがために問題が解けないことは珍しくありません。超重要！！

*** 追加の API

[[https://atcoder.jp/users/maspy][maspy さん]] の [[https://github.com/maspypy/library/blob/fb8c2faf726e432b0d6c976ebb739cf2f040f553/ds/segtree/lazy_segtree.hpp#L157][遅延伝播セグメント木]] では、作用の関数が区間長を受け取ります。

#+BEGIN_SRC cpp
void apply_at(int k, A a) {
  ll sz = 1 << (log - topbit(k));
  dat[k] = AM::act(dat[k], a, sz);
  if (k < size) laz[k] = MA::op(laz[k], a);
}
#+END_SRC

これが非常に上手く働きます:

- $X$ に区間長を埋め込まなくて済みます。
- $F$ から $X$ への作用は、 $X$ に対して制約を設けずに区間長を得ることができます。

[[=ac-library-hs=][=ac-library-hs=]] では真似して =segActWithLength= も用意しています。

#+BEGIN_SRC haskell
class (Monoid f) => SegAct f a where
  {-# INLINE segAct #-}
  segAct :: f -> a -> a
  segAct = segActWithLength 1

  segActWithLength :: Int -> f -> a -> a
#+END_SRC

=segActWithLength= に対しては、以下の等式が成り立つ必要があります:

#+BEGIN_EXPORT markdown
4. `segActWithLength len f a == times len (segAct f a) a`
#+END_EXPORT

以上の性質をテストして行きましょう。

*** テストすべきモノイド

[[=ac-library-hs=][=ac-library-hs=]] では、 =SegAct= のサンプルを =Extra= モジュールで提供します。これらのモノイドをテストして行きましょう。

- [[https://github.com/toyboot4e/ac-library-hs/blob/2a5083aeca24896b9fe595edc0eb7f9e4cc6d8fd/src/AtCoder/Extra/Monoid/Affine1.hs][=Affine1.hs=]] ($f: x \rightarrow a \dot x + b$)
- [[https://github.com/toyboot4e/ac-library-hs/blob/2a5083aeca24896b9fe595edc0eb7f9e4cc6d8fd/src/AtCoder/Extra/Monoid/RangeSetId.hs][=RangeSet=]] ($f: x \rightarrow x + a$)

** 型クラスをテストする

[[https://hackage.haskell.org/package/quickcheck-classes][=quickcheck-classes=]] が良さそうです。モノイド則などのテストが用意されているため、拡張して使います。

*** =tasty= との互換レイヤの作成

[[https://hackage.haskell.org/package/quickcheck-classes][=quickcheck-classes=]] は =tasty= との互換コードを提供していませんが、テストコードの [[https://github.com/andrewthad/quickcheck-classes/blob/6713b482d6b823dce9cc90c48f770b1de98a007d/quickcheck-classes/test/Advanced.hs][=Advanced.hs=]] がそのまま参考になります:

#+BEGIN_SRC haskell
tests :: TestTree
tests = testGroup "universe"
  [ testGroup "deriving"
    [ testGroup "strict"
      [ laws @A [eqLaws,ordLaws]
      , laws @B [eqLaws,ordLaws]
      , laws @F [eqLaws,ordLaws]
      -- ..
#+END_SRC

この =laws= 関数と、 =myForAllShrink= を拝借して =Util.hs= を作ります:

#+BEGIN_SRC haskell
module Tests.Util (myForAllShrink, laws) where

import Data.Proxy (Proxy (..))
import Data.Typeable (Typeable, typeRep)
import Test.QuickCheck.Classes qualified as QCC
import Test.QuickCheck.Property qualified as QC
import Test.Tasty
import Test.Tasty.QuickCheck qualified as QC

myForAllShrink ::
  (QC.Arbitrary a, Show b, Eq b) =>
  Bool -> -- Should we show the RHS. It's better not to show it if the RHS is equal to the input.
  (a -> Bool) -> -- is the value a valid input
  (a -> [String]) -> -- show the 'a' values
  String -> -- show the LHS
  (a -> b) -> -- the function that makes the LHS
  String -> -- show the RHS
  (a -> b) -> -- the function that makes the RHS
  QC.Property
myForAllShrink displayRhs isValid showInputs name1 calc1 name2 calc2 =
  QC.MkProperty $
    QC.arbitrary >>= \x ->
      QC.unProperty $
        QC.shrinking QC.shrink x $ \x' ->
          let b1 = calc1 x'
              b2 = calc2 x'
              sb1 = show b1
              sb2 = show b2
              description = "  Description: " ++ name1 ++ " = " ++ name2
              err = description ++ "\n" ++ unlines (map ("  " ++) (showInputs x')) ++ "  " ++ name1 ++ " = " ++ sb1 ++ (if displayRhs then "\n  " ++ name2 ++ " = " ++ sb2 else "")
           in isValid x' QC.==> QC.counterexample err (b1 == b2)

laws :: forall a. (Typeable a) => [Proxy a -> QCC.Laws] -> TestTree
laws =
  testGroup (show (typeRep (Proxy @a)))
    . map
      ( \f ->
          let QCC.Laws name pairs = f (Proxy @a)
           in testGroup name (map (uncurry QC.testProperty) pairs)
      )
#+END_SRC

*** モノイド則を破っていた

まずは [[https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Monoid.html#t:Monoid][モノイド則]] をテストしました。

#+BEGIN_SRC haskell
module Tests.Extra.Monoid (tests) where

import AtCoder.Extra.Monoid
import Data.Proxy (Proxy (..))
import Data.Semigroup (Max (..), Min (..), Product (..), Sum (..), stimes)
import Test.QuickCheck.Classes qualified as QCC
import Test.QuickCheck.Property qualified as QC
import Test.Tasty
import Test.Tasty.QuickCheck qualified as QC
import Tests.Util (laws, myForAllShrink)

tests :: [TestTree]
tests =
  [ testGroup
      "Affine1"
      [ laws @(Affine1 (Sum Int))
          [ QCC.semigroupLaws,
            QCC.monoidLaws,
            QCC.semigroupMonoidLaws
          ]
      ],
    testGroup
      "RangeSet"
      [ laws @(RangeSet (Sum Int))
          [ QCC.semigroupLaws,
            QCC.monoidLaws,
            QCC.semigroupMonoidLaws
          ]
      ]
  ]
#+END_SRC

=RangeSet= のモノイド則がバグっていました。これが修正前です (=SegAct= の実装は省略します):

#+BEGIN_SRC haskell
newtype RangeSet a = RangeSet a
  deriving newtype (Eq, Ord, Show)

instance Semigroup (RangeSet a) where
  new <> _ = new

instance (Monoid a) => Monoid (RangeSet a) where
  {-# INLINE mempty #-}
  mempty = RangeSet mempty
  {-# INLINE mconcat #-}
  mconcat [] = RangeSet mempty
  mconcat (a : _) = a
#+END_SRC

これが修正後です。 =Bool= のフィールドが =False= の場合は恒等写像 (作用無し) になります:

#+BEGIN_SRC haskell
newtype RangeSet a = RangeSet (RangeSetRepr a)
  deriving newtype (Eq, Ord, Show)

type RangeSetRepr a = (Bool, a)

new :: a -> RangeSet a
new = RangeSet . (True,)

instance Semigroup (RangeSet a) where
  RangeSet (False, !_) <> old = old
  new_ <> _ = new_

instance (Monoid a) => Monoid (RangeSet a) where
  mempty = RangeSet (False, mempty)
  mconcat [] = mempty
  mconcat (RangeSet (False, !_) : as) = mconcat as
  mconcat (a : _) = a
#+END_SRC

これもよくある間違いです。

*** =SegAct= 則をテストする

上記の 4 つの性質をコードで表現します。

#+BEGIN_SRC haskell
module Tests.Extra.Monoid (tests) where

import AtCoder.Extra.Monoid
import Data.Proxy (Proxy (..))
import Data.Semigroup (Max (..), Min (..), Product (..), Sum (..), stimes)
import Test.QuickCheck.Classes qualified as QCC
import Test.QuickCheck.Property qualified as QC
import Test.Tasty
import Test.Tasty.QuickCheck qualified as QC
import Tests.Util (laws, myForAllShrink)

segActLaw :: (Monoid a, Eq a) => (SegAct f a, QC.Arbitrary f, Eq f, Show f, QC.Arbitrary f, QC.Arbitrary a, Show a) => Proxy (f, a) -> QCC.Laws
segActLaw p =
  QCC.Laws
    "SegAct"
    [ ("Monoid Action", segActMonoidAction p),
      ("Identity map", segActIdentity p),
      ("Endomorphism", segActEndomorphism p),
      ("Linear Monoid Action", segActLinearMonoidAction p)
    ]

segActIdentity :: forall f a. (SegAct f a, QC.Arbitrary f, Eq f, Show f, Monoid a, Eq a, QC.Arbitrary a, Show a) => Proxy (f, a) -> QC.Property
segActIdentity _ = myForAllShrink True (const True) desc lhsS lhs rhsS rhs
  where
    desc :: a -> [String]
    desc (a :: a) = ["a = " ++ show a]
    lhsS = "segAct mempty a"
    lhs = segAct (mempty @f)
    rhsS = "a"
    rhs = id

segActMonoidAction :: forall f a. (SegAct f a, QC.Arbitrary f, Eq f, Show f, Monoid a, Eq a, QC.Arbitrary a, Show a) => Proxy (f, a) -> QC.Property
segActMonoidAction _ = myForAllShrink True (const True) desc lhsS lhs rhsS rhs
  where
    desc :: (f, f, a) -> [String]
    desc (!f2, !f1, !a) = ["f2 = " ++ show f2 ++ ", f1 = " ++ show f1 ++ ", a = " ++ show a]
    lhsS = "(f_2 <> f_1) a"
    lhs (!f2, !f1, !a) = (f2 <> f1) `segAct` a
    rhsS = "f_2 (f_1 a)"
    rhs (!f2, !f1, !a) = f2 `segAct` (f1 `segAct` a)

segActEndomorphism :: forall f a. (SegAct f a, QC.Arbitrary f, Eq f, Show f, Monoid a, Eq a, QC.Arbitrary a, Show a) => Proxy (f, a) -> QC.Property
segActEndomorphism _ = myForAllShrink True (const True) desc lhsS lhs rhsS rhs
  where
    desc :: (f, a, a) -> [String]
    desc (!f, !a1, !a2) = ["f = " ++ show f ++ ", a1 = " ++ show a1 ++ ", a2 = " ++ show a2]
    lhsS = "f (a1 <> a2)"
    lhs (!f, !a1, !a2) = segActWithLength 2 f (a1 <> a2)
    rhsS = "(f a1) <> (f a2)"
    rhs (!f, !a1, !a2) = (f `segAct` a1) <> (f `segAct` a2)

segActLinearMonoidAction :: forall f a. (SegAct f a, QC.Arbitrary f, Eq f, Show f, Monoid a, Eq a, QC.Arbitrary a, Show a) => Proxy (f, a) -> QC.Property
segActLinearMonoidAction _ = myForAllShrink True (const True) desc lhsS lhs rhsS rhs
  where
    desc :: (QC.Positive Int, f, a) -> [String]
    desc (QC.Positive !len, !f, !a) = ["len = " ++ show len ++ ", f = " ++ show f ++ ", a = " ++ show a]
    lhsS = "segActWithLength len f (a^len)"
    lhs (QC.Positive !len, !f, !a) = segActWithLength len f $! stimes len a
    rhsS = "(f a)^len"
    rhs (QC.Positive !len, !f, !a) = stimes len (segAct f a)
#+END_SRC

これがやりたかったんですねー。やりました。

** まとめ

念願のモノイドのテストを作成しました。 [[https://hackage.haskell.org/package/quickcheck-classes][=quickcheck-classes=]] の仕組みに乗っかって、半群やモノイドの性質に加えて遅延伝播セグメント木の作用 (=SegAct=) の性質もチェックできました。

モノイド則や恒等写像が間違っていたり、作用の対象のインスタンスを =Num a= のように広く取り過ぎていたことに気付きました。非常に有意義なテストになりました。

コンテストの本番では、もう少しポータブルな関数で PBT できると良さそうです。

* 遅くない ModInt
:PROPERTIES:
:EXPORT_FILE_NAME: modint
:END:

* 終わりに
:PROPERTIES:
:EXPORT_FILE_NAME: end
:END:

* 付録 A. ox-zenn.el
:PROPERTIES:
:EXPORT_FILE_NAME: ox-zenn
:END:

この投稿は Emacs の [[https://orgmode.org/][org-mode]] で作成し、 [[https://github.com/conao3/ox-zenn.el][=ox-zenn.el=]] により Zeen Markdown に変換して生成しました。

#+BEGIN_EXPORT markdown
https://zenn.dev/conao3/articles/ox-zenn-usage
#+END_EXPORT

具体的には、以下のような =.org= ファイルを自作関数に食わせて、 =config.yaml= や =.md= ファイルを生成しています。

#+BEGIN_SRC org
,#+TITLE: 競プロ盆栽.hs
,#+BOOK_DIR: ../books/kyopro-bonsai-hs
,#+PROPERTY: header-args :results output

,* 記事一覧の生成スクリプト

,#+NAME: zenn-headings
,#+BEGIN_SRC elisp :results output
(org-map-entries
  (lambda ()
    (let* ((title (org-entry-get nil "EXPORT_FILE_NAME"))
           (is-draft (org-entry-get nil "DRAFT")))
      (when (and title (not is-draft))
        (princ (concat "- " title "\n")))))
  "LEVEL=1")
,#+END_SRC

,* =config.yaml=

,#+BEGIN_SRC yaml :tangle ../books/kyopro-bonsai-hs/config.yaml :noweb yes
:title: "競プロ盆栽.hs"
:summary: "Haskell の AtCoder 用自作ライブラリ解説"
:topics: ["haskell", "atcoder"]
:published: false
:price: 0
:chapters:
<<zenn-headings()>>
,#+END_SRC

,* 表紙
,:PROPERTIES:
,:EXPORT_FILE_NAME: cover
,:END:

..

,* 始めに
,:PROPERTIES:
,:EXPORT_FILE_NAME: intro
,:END:

..
#+END_SRC

見出しの並びがそのまま Zenn Book と対応します。実際に Book を書くと分かりますが、 slug (ファイル名) で =.md= がソートされると見出しと一致しなくて不便です。 =ox-zenn.el= のおかげで快適に作成できました。

#+BEGIN_EXPORT markdown
https://github.com/conao3/ox-zenn.el
#+END_EXPORT

